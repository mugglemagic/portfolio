<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)" />
		<meta name="theme-color" content="#0a0a0a" media="(prefers-color-scheme: dark)" />
		<link rel="icon" href="/favicon.svg" type="image/svg+xml" />
		<link rel="manifest" href="/manifest.webmanifest" />
		<!-- Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link href="https://fonts.googleapis.com/css2?family=Google+Sans+Code:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet" />
		
		<link href="../_app/immutable/assets/0.BF8zXpst.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.gJeQT9fj.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/XUMD-9Mr.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BNPA_p_8.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.6Y1gGeRj.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DCf4JqPx.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/B-iva8rw.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/C8YSO-qe.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/BqisEWkp.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/B4GcWvgj.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.B6H7cPzz.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/DmT9Q6NN.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/D0ihxO46.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/Dg5uvz-Z.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/IVcZ5moH.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/Cw41v0MJ.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/5.DBA4cNcK.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/QRiZD35W.js"><!--1mz03nk--><!--[!--><!--]--> <!----><script>(function setInitialMode({ defaultMode = "system", themeColors: themeColors2, darkClassNames: darkClassNames2 = ["dark"], lightClassNames: lightClassNames2 = [], defaultTheme = "", modeStorageKey: modeStorageKey2 = "mode-watcher-mode", themeStorageKey: themeStorageKey2 = "mode-watcher-theme" }) {
  const rootEl = document.documentElement;
  const mode = localStorage.getItem(modeStorageKey2) ?? defaultMode;
  const theme = localStorage.getItem(themeStorageKey2) ?? defaultTheme;
  const light = mode === "light" || mode === "system" && window.matchMedia("(prefers-color-scheme: light)").matches;
  if (light) {
    if (darkClassNames2.length)
      rootEl.classList.remove(...darkClassNames2.filter(Boolean));
    if (lightClassNames2.length)
      rootEl.classList.add(...lightClassNames2.filter(Boolean));
  } else {
    if (lightClassNames2.length)
      rootEl.classList.remove(...lightClassNames2.filter(Boolean));
    if (darkClassNames2.length)
      rootEl.classList.add(...darkClassNames2.filter(Boolean));
  }
  rootEl.style.colorScheme = light ? "light" : "dark";
  if (themeColors2) {
    const themeMetaEl = document.querySelector('meta[name="theme-color"]');
    if (themeMetaEl) {
      themeMetaEl.setAttribute("content", mode === "light" ? themeColors2.light : themeColors2.dark);
    }
  }
  if (theme) {
    rootEl.setAttribute("data-theme", theme);
    localStorage.setItem(themeStorageKey2, theme);
  }
  localStorage.setItem(modeStorageKey2, mode);
})({"defaultMode":"system","darkClassNames":["dark"],"lightClassNames":[],"defaultTheme":"","modeStorageKey":"mode-watcher-mode","themeStorageKey":"mode-watcher-theme"});</script><!----><!----><!--ojxrft--><meta name="description" content="Building full-stack observability with OpenTelemetry - from browser spans to backend traces, and everything in between."/> <link rel="canonical" href="https://markbasford.com/blog/FR-0006-the-observability-iceberg"/> <meta property="og:type" content="article"/> <meta property="og:url" content="https://markbasford.com/blog/FR-0006-the-observability-iceberg"/> <meta property="og:title" content="The Observability Iceberg | Mark Basford"/> <meta property="og:description" content="Building full-stack observability with OpenTelemetry - from browser spans to backend traces, and everything in between."/> <meta property="og:image" content="https://markbasford.com/headshot.jpg"/> <meta property="og:image:width" content="1200"/> <meta property="og:image:height" content="630"/> <meta name="twitter:card" content="summary_large_image"/> <meta name="twitter:title" content="The Observability Iceberg | Mark Basford"/> <meta name="twitter:description" content="Building full-stack observability with OpenTelemetry - from browser spans to backend traces, and everything in between."/> <meta name="twitter:image" content="https://markbasford.com/headshot.jpg"/> <!--[--><meta name="author" content="Mark Basford"/> <!--[--><meta property="article:published_time" content="2025-01-21T00:00:00.000Z"/><!--]--> <meta property="article:author" content="Mark Basford"/> <!--[--><meta property="article:tag" content="observability, telemetry, opentelemetry, tracing, performance, debugging"/><!--]--><!--]--> <!----><script type="application/ld+json">{"@context":"https://schema.org","@type":"Person","name":"Mark Basford","url":"https://markbasford.com","jobTitle":"Frontend Architect","description":"Frontend architect specialising in accessibility-first development","sameAs":["https://www.linkedin.com/in/mark-basford-78a43390/","https://github.com/mugglemagic"],"knowsAbout":["Web Accessibility","Frontend Development","React","Vue","SvelteKit","TypeScript","PHP","Laravel"]}</script><!----> <!--[--><!----><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Observability Iceberg | Mark Basford","description":"Building full-stack observability with OpenTelemetry - from browser spans to backend traces, and everything in between.","datePublished":"2025-01-21T00:00:00.000Z","author":{"@type":"Person","name":"Mark Basford","url":"https://markbasford.com"},"publisher":{"@type":"Person","name":"Mark Basford"}}</script><!----><!--]--><!----><title>The Observability Iceberg | Mark Basford</title>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><!--[!--><!--]--><!----> <a href="#main-content" class="skip-link svelte-supu7d">Skip to main content</a><!----> <div class="flex min-h-screen flex-col"><header class="border-b border-border"><div class="mx-auto flex max-w-4xl items-center justify-between px-6 py-6"><a href="/" class="text-lg font-medium tracking-tight transition-opacity hover:opacity-60">Mark Basford</a> <nav aria-label="Main navigation" class="flex items-center gap-1"><!--[--><a href="/" class="min-h-[44px] min-w-[44px] inline-flex items-center justify-center px-4 py-2 text-sm transition-opacity hover:opacity-60 focus-visible:outline-2 focus-visible:outline-offset-4 focus-visible:outline-ring opacity-60">Home</a><a href="/about" class="min-h-[44px] min-w-[44px] inline-flex items-center justify-center px-4 py-2 text-sm transition-opacity hover:opacity-60 focus-visible:outline-2 focus-visible:outline-offset-4 focus-visible:outline-ring opacity-60">About</a><a href="/blog" class="min-h-[44px] min-w-[44px] inline-flex items-center justify-center px-4 py-2 text-sm transition-opacity hover:opacity-60 focus-visible:outline-2 focus-visible:outline-offset-4 focus-visible:outline-ring opacity-100" aria-current="page">Blog</a><!--]--> <!--[!--><button data-slot="button" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium outline-none transition-all focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&amp;_svg:not([class*='size-'])]:size-4 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-9 min-h-[44px] min-w-[44px]" type="button" aria-label="Toggle theme"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="hidden dark:block"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" class="block dark:hidden"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg><!----></button><!--]--><!----></nav></div></header><!----> <main id="main-content" tabindex="-1" class="flex-1"><!----><!----> <article class="mx-auto max-w-3xl px-6 py-16 md:py-24"><header class="mb-16"><a href="/blog" class="label mb-8 inline-flex min-h-[44px] items-center gap-2 transition-transform hover:opacity-60"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg> Back to blog</a> <h1 class="mb-6">The Observability Iceberg</h1> <div class="flex flex-wrap items-center gap-3"><time datetime="2025-01-21T00:00:00.000Z" class="label">21 January 2025</time> <!--[--><span class="text-border">|</span> <!--[--><span class="label">observability</span><span class="label">telemetry</span><span class="label">opentelemetry</span><span class="label">tracing</span><span class="label">performance</span><span class="label">debugging</span><!--]--><!--]--></div></header> <div class="prose"><!--[--><!----><p>On August 1st, 2012, Knight Capital deployed new trading software to their production servers. Within forty-five minutes, they’d lost $440 million. The company was effectively bankrupt by lunchtime.</p> <p>The cause was almost mundane: old code accidentally reactivated during deployment. A function that hadn’t run in years suddenly started executing, making bizarre trades at machine speed. Knight Capital had monitoring. They had alerts. What they didn’t have was any way to correlate the behaviour - to see the flow of orders through their system and understand <em>why</em> the numbers were going wrong.</p> <p>By the time humans pieced together what was happening, it was over. Distributed tracing showing the journey of each order would have made the anomaly obvious within minutes. Instead, engineers were staring at dashboards full of red indicators, trying to manually reconstruct a story the system should have been telling them.</p> <p>We think about Knight Capital more than we probably should.</p> <h2>The 10% Problem</h2> <p>Here’s the uncomfortable truth about traditional logging: you’re seeing maybe 10% of what you need to understand a problem. An error message tells you something broke. It doesn’t tell you why, or what happened in the fifteen steps before the break, or whether those steps took milliseconds or minutes, or which user action triggered the whole chain.</p> <p>Logs are snapshots. Production issues are movies.</p> <p>We’ve lived this in legacy systems. An error appears in the logs. We know it happened. We know roughly when. But replicating it? Understanding the state that led to it? That’s where hours disappear. Someone starts adding temporary logging statements. Someone else tries to reproduce the issue locally. A third person is cross-referencing timestamps across different log files, building a mental model of what <em>might</em> have occurred.</p> <p>Meanwhile, users are still hitting the problem. And we’re still guessing.</p> <p>The development team loses half a day on something that proper tracing would have revealed in five minutes. Multiply that across a year, across every hard-to-reproduce bug, every “works on my machine” investigation, every cross-team finger-pointing session about whether the frontend or backend caused the issue. The cost isn’t dramatic like Knight Capital. It’s the slow erosion of velocity, the accumulated friction of debugging blind.</p> <h2>Tracing the Journey</h2> <p>The principle that changed our approach: the journey matters, not just the destination.</p> <p>When a user clicks “Sign Up” and something fails, the error message is the destination. But the journey - form submission, validation, API call, database write, response handling - that’s where the actual problem lives. Tracing captures the journey.</p> <pre class="language-undefined"><!----><code class="language-undefined">Trace ID: abc123 (Duration: 850ms)
│
├─ eventbus.publish [auth.signup.submit] (50ms)
│  └─ eventbus.handler_execution (35ms)
│     └─ auth.signup (600ms)
│        ├─ HTTP POST /api/auth/user-check (400ms)
│        │  └─ [Backend] Database query (50ms)
│        └─ eventbus.publish [auth.user-check.received] (50ms)
└─ navigation.redirect (5ms)</code><!----></pre> <p>One trace ID. The complete story. Every step timed, every handoff recorded, every service connected. When that signup fails, we don’t ask “what happened?” We look at trace <code>abc123</code> and <em>see</em> what happened.</p> <p>The backend team doesn’t need to defend themselves. The frontend team doesn’t need to prove they sent the right data. Everyone looks at the same trace and the bottleneck - or the failure point - is simply visible.</p> <h2>The Dual-Layer Architecture</h2> <p>Problems happen in two places: the server and the browser. Traditional observability often ignores the browser entirely. But the user’s experience happens in the browser. Network issues, slow renders, client-side errors - these are invisible if you’re only watching the server.</p> <p>We instrument both.</p> <p><strong>Server-side</strong>: Next.js provides automatic instrumentation for server actions, API routes, and middleware. Every request that hits our server generates spans without us writing instrumentation code.</p> <p><strong>Browser-side</strong>: A custom OpenTelemetry implementation that captures what happens in the user’s actual environment. Page loads, component renders, API calls from the client, user interactions that trigger chains of events.</p> <p>The magic is in the correlation. When the browser makes an HTTP request, it includes a <code>traceparent</code> header:</p> <pre class="language-undefined"><!----><code class="language-undefined">traceparent: 00-&#123;trace-id&#125;-&#123;span-id&#125;-01</code><!----></pre> <p>That header tells the backend: “I’m part of trace <code>abc123</code>.” The backend extracts the ID, creates its own spans as children, and suddenly you have one trace spanning browser, API, and database. The user’s click, the server’s processing, the database’s query - all connected, all visible, all timed.</p> <p>When the frontend team says “we sent the request” and the backend team says “we never received it,” the trace settles it instantly. Either the browser span shows the request was sent, or it doesn’t. Either the server span shows it arrived, or it doesn’t. No more archaeology through timestamp correlations across separate log files.</p> <h2>The Sampling Reality</h2> <p>Here’s where theory meets economics.</p> <p>Tracing everything in production would generate terabytes of data. The bandwidth costs alone would be significant. The storage costs would be worse. And most of that data would be perfectly normal requests that nobody ever looks at.</p> <p>So we sample. But sampling naively creates its own problems. If you randomly sample 5% of spans, you get fragments - the beginning of a trace without the end, a database query without the API call that triggered it. Useless for debugging.</p> <p>Our approach: session-based sampling with error overrides.</p> <p><strong>In development</strong>: 100% sampling. Every trace, every span. You’re debugging, you need to see everything.</p> <p><strong>In production</strong>: 5% of sessions are sampled. The key word is <em>sessions</em>. We hash the session ID deterministically, and if that session falls in the sampled 5%, every span in that session is kept. You get complete traces, not random fragments. A coherent 5% sample tells you more than an incoherent 100%.</p> <p><strong>Errors</strong>: 100% sampling, always. When something fails, we keep the trace regardless of the session sampling decision. You never lose visibility into problems because of sampling.</p> <p><strong>Slow requests</strong>: If a request takes more than a second, it’s sampled. Performance problems are problems too.</p> <pre class="language-typescript"><!----><code class="language-typescript"><span class="token comment">// Configuration</span>
<span class="token constant">NEXT_PUBLIC_OTEL_TRACE_SAMPLE_RATE</span><span class="token operator">=</span><span class="token number">0.05</span>    <span class="token comment">// 5% in production</span>
<span class="token constant">NEXT_PUBLIC_OTEL_ERROR_SAMPLE_RATE</span><span class="token operator">=</span><span class="token number">1.0</span>     <span class="token comment">// 100% of errors</span></code><!----></pre> <p>The result: sustainable costs, coherent data, and guaranteed visibility into the things that matter.</p> <h2>Performance Without Sacrifice</h2> <p>Observability that slows down the application is self-defeating. You can’t measure performance while degrading it.</p> <p>The browser telemetry is lazy-loaded. It doesn’t block the initial page render. The user sees the application while the instrumentation initialises in the background. Bundle impact is under 150KB gzipped - substantial enough to take seriously, but not enough to noticeably affect load times.</p> <p>Traces are batched and exported asynchronously. The act of recording a span doesn’t block the operation being recorded. If the observability backend is unreachable, data is dropped silently rather than queued indefinitely or retried aggressively.</p> <p>Graceful degradation throughout. If telemetry initialisation fails, the application continues normally. Components check whether telemetry is available before attempting to use it. No user ever sees an error because observability broke.</p> <p>The overhead in production: under 2% with 5% sampling. Measurable if you’re looking for it, invisible to users.</p> <h2>What We Actually See Now</h2> <p>The dashboard shows services: <code>eos-frontend-browser</code>, <code>eos-frontend-main</code>, and downstream. You can search by trace ID, operation name, time range. Filter to errors only. Look at the waterfall view of a request’s complete lifecycle.</p> <p>When something breaks, we don’t start the archaeology. We find the trace. Often the user’s error report includes enough information to locate it - the time, the page, the action they were taking. Sometimes we search for error spans in the relevant time window.</p> <p>Either way, the debugging starts from understanding rather than guessing.</p> <p>The cross-team conversations changed too. “Check trace ID <code>abc123</code>” is a complete handoff. Frontend, backend, database - everyone sees the same story. The trace is the single source of truth about what happened.</p> <h2>Knight Capital’s Ghost</h2> <p>We’re not trading millions of dollars per second. An observability gap won’t bankrupt us in forty-five minutes. But the principle holds at any scale: when systems behave unexpectedly, the speed of understanding determines the cost of the problem.</p> <p>Knight Capital had alerts. They had monitoring. What they lacked was the ability to see the journey - to correlate individual actions into a coherent story fast enough to act on it.</p> <p>We can’t guarantee we’ll never have a production incident. But we can guarantee that when something goes wrong, we’ll be looking at the trace, not staring at dashboard alerts trying to manually reconstruct what the system should have been telling us all along.</p> <p>The error message is the tip of the iceberg. The trace shows you what’s underneath.</p> <hr/> <h2>Technical Notes</h2> <p><strong>Architecture:</strong></p> <ul><li>Server-side: Vercel OTEL integration for Next.js</li> <li>Browser-side: Custom OpenTelemetry with TelemetryProvider</li> <li>Trace correlation via <code>traceparent</code> header propagation</li> <li>Session-based sampling with error/slow-request overrides</li></ul> <p><strong>Key Files:</strong></p> <ul><li><code>packages/ui/providers/TelemetryProvider/</code> - React context and hooks</li> <li><code>services/modules/telemetry/</code> - Browser instrumentation services</li> <li><code>apps/*/instrumentation.ts</code> - Server-side OTEL registration</li></ul> <p><strong>Related Posts:</strong></p> <ul><li>FR-0005: The Server-Side Shield (security events need observability)</li> <li>FR-0001: The Multizone Gambit (tracing across zones)</li></ul> <p><strong>References:</strong></p> <ul><li><a href="https://en.wikipedia.org/wiki/Knight_Capital_Group#2012_stock_trading_disruption" rel="nofollow">Knight Capital Group Trading Loss</a></li> <li><a href="https://opentelemetry.io/docs/" rel="nofollow">OpenTelemetry Documentation</a></li> <li><a href="https://www.w3.org/TR/trace-context/" rel="nofollow">W3C Trace Context Specification</a></li></ul> <hr/> <h2>A Note on How This Was Written</h2> <p>As with all posts in this series, this was written with AI assistance. The architectural decisions and the legacy debugging frustrations are real. Knight Capital’s story informed our thinking about what observability actually means - not just having data, but being able to understand it fast enough to matter.</p><!----><!--]--></div></article><!----><!----></main> <footer class="border-t border-border"><div class="mx-auto flex max-w-4xl flex-col items-center gap-6 px-6 py-12 sm:flex-row sm:justify-between"><p class="text-sm text-muted-foreground">© 2025 Mark Basford</p> <nav aria-label="Social links" class="flex items-center gap-2"><!--[--><a href="https://www.linkedin.com/in/mark-basford-78a43390/" target="_blank" rel="noopener noreferrer" class="inline-flex min-h-[44px] min-w-[44px] items-center justify-center rounded-md p-2 transition-opacity hover:opacity-70 focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-ring" aria-label="LinkedIn (opens in new tab)"><!--[--><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect width="4" height="12" x="2" y="9"></rect><circle cx="4" cy="4" r="2"></circle></svg><!--]--></a><a href="https://github.com/mugglemagic" target="_blank" rel="noopener noreferrer" class="inline-flex min-h-[44px] min-w-[44px] items-center justify-center rounded-md p-2 transition-opacity hover:opacity-70 focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-ring" aria-label="GitHub (opens in new tab)"><!--[!--><!--[--><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg><!--]--><!--]--></a><!--]--></nav><!----></div></footer><!----></div><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_moh665 = {
						base: new URL("..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../_app/immutable/entry/start.gJeQT9fj.js"),
						import("../_app/immutable/entry/app.6Y1gGeRj.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 5],
							data: [null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
